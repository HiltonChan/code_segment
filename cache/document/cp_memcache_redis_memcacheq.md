## Memcache、Redis和Memcacheq ##

###Memcache
######类型：
高性能的分布式内容对象缓存系统。
######作用：
通过在内存中缓存数据和对象来减少读取数据库的次数，从而提高动态、数据库驱动网站的速度。
######存储结构：
基于存储键值对的hashmap。
######存储方法：
为了提高性能，memcache中的数据都存储在memcache内置的存储空间中，所以重启memcache会导致数据丢失，当数据存储量达到最大之后，就会使用LRU算法删除不用的缓存。
######工作模式：
以守护进程的模式工作于后台，通过自定义的memcache协议进行通信。
######特点：
- 协议简单
- 支持数据遍历
- 支持条件查询
- 支持数据、JSON等序列化字符的反序列化显示
- 支持连接池
- 自主内存分配策略
- 具有分布式
- C/S架构
######缺点：
- 缺乏认证和安全管理机制
- LRU算法的处理不够高效
- 数据容易丢失，缺乏永久性
- 删除缓存的时机策略过于简单
- Slab Allocation的内存分配存在浪费问题

###Redis
######类型：
高性能的key-value数据库。
######存储结构：
也是key/value的模型，支持包括string(字符串)、list(链表)、set(集合)、zset(sorted set --有序集合)和hash（哈希类型）。
######工作模式：
为了保证高性能，将数据存在内存中；为了保证数据的永久性，周期性将数据同步到磁盘中。
######用途：
**存储**<br>
可以用于永久性存储数据，跟NoSQL数据库类似。<br>
**缓存**<br>
可以作为缓存系统，设置key、value，支持对可以key设置对应的时效，支持设置数据的最大空间，当空间达到一定量后会使用对应策略进行删除。<br>
**队列**<br>
列表类型键可以用来实现队列，并支持阻塞时读取，可以很容易地实现一个高性能的优先级队列。<br>
######特点：
- 丰富的数据类型，包括set、list、zset、hash
- 性能高
- 特性多，支持publish/subscribe等
- 数据永久性存储

######缺点：
- 不支持自定义数据库名字
- 在数据库访问方面缺乏安全性
- 内存消耗率过高
- 持久化的策略效率低

###Memcacheq
######类型：
消息队列存储系统。


###对比
<table>
  <thead>
    <tr>
      <th></th>
      <th>Memcache</th>
      <th>Redis</th>
      <th>Memcacheq</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>线程模型</td>
      <td>多线程</td>
      <td>单线程</td>
      <td></td>
    </tr>
    <tr>
      <td>工作核数</td>
      <td>基于多核</td>
      <td>基于单核</td>
      <td></td>
    </tr>
	<tr>
      <td>数据类型支持</td>
      <td>类型单一</td>
      <td>多类型支持</td>
      <td></td>
    </tr>
	<tr>
      <td>内存管理机制</td>
      <td>Slab Allocation机制</td>
      <td>详细的内存分配记录</td>
      <td></td>
    </tr>
	<tr>
      <td>数据持久化</td>
      <td>不支持</td>
      <td>支持</td>
      <td></td>
    </tr>
	<tr>
      <td>分布式类型</td>
      <td>客户端实现</td>
      <td>服务端实现</td>
      <td></td>
    </tr>
	<tr>
      <td>数据库备份的支持</td>
      <td>否</td>
      <td>是</td>
      <td></td>
    </tr>
	<tr>
      <td>事务支持</td>
      <td>是，通过CAS</td>
      <td>比较弱</td>
      <td></td>
    </tr>
  </tbody>
</table>

###应用场景
**Redis：**应用于数据量较小的高性能操作和运算上。<br>
**Memcache：**用于在动态系统中做Cache层，减少数据库负载，提升性能，适用于数据量大的时候，可以采用分布式。<br>
**Memcacheq：**主要用于对消息建立一个处理队列，一个进程投放消息，一个进程处理消息，实现异步。<br>

###我的看法和疑点
**Memcache的LRU策略真的好？**<br>
个人觉得LRU算法的核心是检测出最近最少用的那个缓存数据，但是这个并不代表未来的这个缓存的数据被命中的几率是最低的，我们对过期缓存的最佳算法是删除未来缓存命中率最低的一个。对于Memcache中无法对实际的业务作出统一的接口，但是个人觉得可以提供外部实现的接口，一个控制缓存删除的接口，给用户自己去实现。<br>
**Memcache的缓存删除时机对？**<br>
Memcache中对缓存的删除是等到有新的内容过来，如果检测到缓存中没有多余位置的话，就会根据LRU策略是删除缓存。但是很明显，这种做法会造成时延，如果要删除的缓存很大，那么你在删除的时候话费的时间也会很大，这样产生的时延问题感觉是挺严重的。